(() => {
  'use strict';
  var t = {
    d: (e, o) => {
      for (var s in o)
        t.o(o, s) &&
          !t.o(e, s) &&
          Object.defineProperty(e, s, { enumerable: !0, get: o[s] });
    },
    o: (t, e) => Object.prototype.hasOwnProperty.call(t, e),
    r: (t) => {
      'undefined' != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(t, '__esModule', { value: !0 });
    },
  };
  t.d({}, { d$: () => A, Wn: () => R, oD: () => I, u4: () => D });
  var e = {};
  function o(t, e, o) {
    const s = document.createElement(t);
    return (s.className = e), o && o.forEach((t) => s.appendChild(t)), s;
  }
  function s(t, e) {
    return o('div', t, e);
  }
  function i(t, e, o) {
    return Math.min(Math.max(t, e), o);
  }
  function a(t) {
    return Math.floor(t * Math.random());
  }
  function n() {
    return 2e3 + 8e3 * Math.random();
  }
  t.r(e),
    t.d(e, {
      AccelTime: () => d,
      BlinkClass: () => b,
      BlinkTime: () => T,
      BoopFace: () => B,
      BottomColors: () => _,
      BottomStyles: () => E,
      DecelDist: () => p,
      DecelTargetSpeed: () => g,
      EyeRadiusX: () => f,
      EyeRadiusY: () => w,
      EyeYOffset: () => y,
      FaceColors: () => L,
      IdealDistance: () => c,
      LeftEyeXOffset: () => k,
      Margin: () => l,
      MaxEyeY: () => m,
      MaxLookDistance: () => x,
      MaxSpeed: () => u,
      Radius: () => r,
      RightEyeXOffset: () => v,
      WaistColors: () => M,
    });
  class h {
    constructor(t, e, o) {
      (this.x = t),
        (this.y = e),
        (this.solid = !0),
        (this.update = []),
        (this.click = []),
        (this.face = null),
        (this.chatterTimeoutId = null),
        (this.faceTimeoutId = null),
        (this.pauseFollow = !1),
        (this.pauseLook = !1),
        (this.pauseBlink = !1),
        (this.pauseIdleLook = !1),
        (this.lookAt = null),
        (this.target = null),
        (this.hasNarrator = !1),
        (this.propagandaStarted = !1),
        this.createElements(),
        this.place(t, e),
        o && o(this);
    }
    createElements() {
      const t = FaceColors[a(FaceColors.length)],
        e = WaistColors[a(WaistColors.length)],
        i = BottomColors[a(BottomColors.length)],
        n = BottomStyles[a(BottomStyles.length)];
      (this.outer = s(
        [
          'owo',
          'owo--f-' + t,
          'owo--m-' + e,
          'owo--b-' + i,
          'owo--b-' + n,
        ].join(' '),
        [
          (this.inner = s('owo__bot', [
            s('owo__face'),
            (this.leftEye = s('owo__o owo__o--left', [
              (this.leftPupil = s('owo__pupil')),
            ])),
            s('owo__w'),
            (this.rightEye = s('owo__o owo__o--right', [
              (this.rightPupil = s('owo__pupil')),
            ])),
            s('owo__middle'),
            s('owo__bottom', [s('owo__center')]),
          ])),
          (this.chatter = s('owo__chatter propaganda-no-mangle', [
            o('span', 'sr-only', [
              document.createTextNode('Helper bot says: '),
            ]),
            (this.chatterText = o('span', '', [
              document.createTextNode('You can click me!'),
            ])),
          ])),
        ]
      )),
        (this.outer.style.width = 2 * Radius + 'px'),
        (this.outer.style.height = 2 * Radius + 'px'),
        (this.inner.tabIndex = 0),
        this.inner.setAttribute('role', 'button'),
        this.inner.setAttribute(
          'aria-label',
          i + ' helper bot with ' + t + ' eyes'
        ),
        this.inner.addEventListener('click', (t) => this.doClick(t)),
        this.inner.addEventListener('keydown', (t) => {
          ('Enter' !== t.key && ' ' !== t.key) || this.doClick(t);
        }),
        this.inner.addEventListener('mousedown', (t) => {
          t.preventDefault();
        }),
        this.chatter.setAttribute('aria-live', 'assertive'),
        this.chatter.setAttribute('aria-atomic', 'true'),
        this.chatter.addEventListener('animationend', () => {
          this.chatter.classList.contains('owo__chatter--enter') &&
            (this.chatter.classList.add('owo__chatter--visible'),
            this.chatter.classList.remove('owo__chatter--enter')),
            this.chatter.classList.contains('owo__chatter--leave') &&
              this.chatter.classList.remove(
                'owo__chatter--visible',
                'owo__chatter--leave'
              );
        });
    }
    doClick(t) {
      for (let e = 0; e < this.click.length; e++) this.click[e](t);
    }
    place(t, e) {
      t !== this.x &&
        ((this.outer.style.left = Math.round(t - Radius) + 'px'), (this.x = t)),
        e !== this.y &&
          ((this.outer.style.top = Math.round(e - Radius) + 'px'),
          (this.y = e));
    }
    say(t, e) {
      this.chatter.classList.remove(
        'owo__chatter--enter',
        'owo__chatter--leave',
        'owo__chatter--visible'
      ),
        clearTimeout(this.chatterTimeoutId),
        setTimeout(() => {
          (this.chatterText.textContent = t),
            this.chatter.classList.add('owo__chatter--enter');
        }, 0),
        (this.chatterTimeoutId = setTimeout(() => {
          this.chatter.classList.add('owo__chatter--leave');
        }, e || 2500));
    }
    showFace(t, e) {
      clearTimeout(this.faceTimeoutId),
        this.face &&
          (this.outer.classList.remove(this.face), (this.face = null)),
        (this.face = t),
        this.outer.classList.add(t),
        (this.faceTimeoutId = setTimeout(() => {
          this.outer.classList.remove(t);
        }, e || 1e3));
    }
    attachFollow() {
      let t = 0;
      this.update.push((e, o) => {
        if (this.pauseFollow) return;
        let { x: s, y: a } = this,
          n = this.getTarget(this.target || R),
          h = n.x - s,
          r = n.y - a,
          l = Math.sqrt(h * h + r * r);
        if (l > IdealDistance)
          if (
            ((n = (function (t, e, o) {
              const s = Math.atan2(o, e);
              return {
                x: i(
                  t.x - IdealDistance * Math.cos(s),
                  Radius + Margin,
                  window.innerWidth - Radius - Margin
                ),
                y: i(
                  t.y - IdealDistance * Math.sin(s),
                  Radius + Margin,
                  window.innerHeight - Radius - Margin
                ),
              };
            })(n, h, r)),
            (h = n.x - s),
            (r = n.y - a),
            (l = Math.sqrt(h * h + r * r)),
            l < 1)
          )
            (t = 0), (s = n.x), (a = n.y);
          else {
            0 === t && (t = e);
            const i = (function (t, e, o) {
              let s = MaxSpeed;
              if (e < AccelTime) {
                const t = e / AccelTime;
                s = MaxSpeed * t * t;
              }
              let i = MaxSpeed;
              if (o < DecelDist) {
                const t = o / DecelDist;
                i = DecelTargetSpeed + (MaxSpeed - DecelTargetSpeed) * t * t;
              }
              const a = Math.min(s, i);
              return Math.min((a * t) / 1e3, o);
            })(o, e - t, l);
            let n = Math.atan2(r, h);
            (s += i * Math.cos(n)), (a += i * Math.sin(n));
          }
        else t = 0;
        this.place(s, a), this.collide();
      });
      let e = 0,
        o = 0,
        s = 0,
        a = 0;
      const n = (t, i) => {
        switch (t.key) {
          case 'Up':
          case 'ArrowUp':
            (e = -i), t.preventDefault();
            break;
          case 'Down':
          case 'ArrowDown':
            (o = i), t.preventDefault();
            break;
          case 'Left':
          case 'ArrowLeft':
            (s = -i), t.preventDefault();
            break;
          case 'Right':
          case 'ArrowRight':
            (a = i), t.preventDefault();
            break;
          default:
            return;
        }
        R =
          s || a || e || o
            ? { dx: (s + a) * MaxLookDistance, dy: (e + o) * MaxLookDistance }
            : this.getTarget(R);
      };
      this.inner.addEventListener('keydown', (t) => {
        n(t, 1);
      }),
        this.inner.addEventListener('keyup', (t) => {
          n(t, 0);
        });
    }
    attachLook() {
      const t = (t, e, o) => {
        const s = this.x + e,
          i = this.y + EyeYOffset,
          a = o.x - s,
          n = o.y - i,
          h = Math.sqrt(a * a + n * n),
          r = Math.atan2(n, a),
          l = Math.min(1, h / MaxLookDistance),
          c = EyeRadiusX * l * Math.cos(r),
          d = Math.min(EyeRadiusY * l * Math.sin(r), MaxEyeY);
        (t.style.left = 'calc(' + c + 'px + 50%)'),
          (t.style.top = 'calc(' + d + 'px + 65%)');
      };
      this.update.push(() => {
        if (this.pauseLook) return;
        const e = this.getTarget(this.lookAt || this.target || R);
        t(this.leftPupil, LeftEyeXOffset, e),
          t(this.rightPupil, RightEyeXOffset, e);
      });
    }
    attachBlink() {
      let t = 0,
        e = !1;
      this.update.push((o) => {
        this.pauseBlink ||
          (0 === t && (t = o + n()),
          o >= t &&
            ((e = !e),
            this.leftEye.classList.toggle(BlinkClass),
            this.rightEye.classList.toggle(BlinkClass),
            (t = o + (e ? BlinkTime : n()))));
      });
    }
    attachIdleLook() {
      const t = () => 2e3 + 4e3 * Math.random();
      let e = null,
        o = null,
        s = null;
      this.update.push((i) => {
        const n = this.getTarget(R);
        this.pauseIdleLook ||
          (o !== n.x || s !== n.y
            ? ((e = null), (this.lookAt = null))
            : null === e
            ? (e = i + t())
            : i > e &&
              ((e = i + t()),
              (this.pauseLook = !1),
              (this.lookAt = {
                x: this.x + a(300) - 150,
                y: this.y + a(300) - 150,
              }))),
          (o = n.x),
          (s = n.y);
      });
    }
    propaganda() {
      if (
        (this.say('Lowong live the revowolution!'),
        this.showFace(BoopFace),
        this.propagandaStarted)
      )
        return;
      (this.propagandaStarted = !0), D('revolution');
      const t = Array.from(document.querySelectorAll('.propaganda-no-mangle')),
        e = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT, {
          acceptNode: (e) =>
            /[oO]/.test(e.data) && !t.some((t) => t.contains(e)),
        });
      let o = e.nextNode();
      const s = /(o(?!o))|(oo)|(O(?=[A-Z]))|(O(?![A-Z]))/g,
        i = setInterval(() => {
          let t = s.exec(o.data);
          if (!t) {
            if (((o = e.nextNode()), !o))
              return (
                console.log('Applied text transformation'),
                void clearInterval(i)
              );
            (s.lastIndex = 0), (t = s.exec(o.data));
          }
          const a = t[2] ? 'oowoo' : t[3] ? 'OWO' : t[4] ? 'Owo' : 'owo';
          o.replaceData(t.index, t[0].length, a),
            (s.lastIndex += a.length - t[0].length);
        }, 100);
    }
    attachBoop(t) {
      const e = [
        '*beep*',
        '*sneeze*',
        'Aaah!',
        'Ohh!',
        'Hey, that tickles!',
        'Hi there!',
      ];
      let o = -1,
        s = 0;
      this.click.push(() => {
        s++;
        const i = t && t[s];
        if (i) i(this, s);
        else {
          let t;
          do {
            t = a(e.length);
          } while (t === o);
          this.say(e[t]), (o = t), this.showFace(BoopFace);
        }
      });
    }
    attachIntroduction(t, e) {
      (this.target = { x: 3 * Radius, y: 2 * Radius + Margin }),
        (this.pauseLook = !0);
      const o = () => {
        if (void 0 !== R.x || 0 !== R.dx || 0 !== R.dy) {
          const t = this.update.indexOf(o);
          this.update.splice(t, 1), (this.target = null), (this.pauseLook = !1);
        }
      };
      this.update.push(o),
        (this.chatterTimeoutId = setTimeout(() => {
          this.say(t), this.showFace(BoopFace);
        }, e || 2e3));
    }
    attachLurk() {
      (this.solid = !1), this.outer.classList.add('owo--lurk');
      const { style: t } = this.outer;
      (t.top = 'auto'),
        (t.left = 'auto'),
        (t.bottom = `-${Math.round(0.8 * Radius)}px`),
        (t.right = '32px');
      let e = !1;
      const o = () => {
        (e = !e),
          this.leftEye.classList.toggle(BlinkClass),
          this.rightEye.classList.toggle(BlinkClass),
          setTimeout(o, e ? BlinkTime : n());
      };
      let s = setTimeout(o, n());
      const i = () => {
        this.click.splice(this.click.indexOf(i), 1),
          clearTimeout(s),
          e &&
            (this.leftEye.classList.remove(BlinkClass),
            this.rightEye.classList.remove(BlinkClass)),
          D('activation');
        const t = this.outer.contains(document.activeElement),
          o = this.outer.getBoundingClientRect();
        this.place(o.left + Radius, o.top + Radius),
          this.outer.style.removeProperty('right'),
          this.outer.style.removeProperty('bottom'),
          this.outer.classList.remove('owo--lurk'),
          A(this),
          document.body.appendChild(this.outer),
          (this.target = { x: this.x, y: this.y - 3 * Radius }),
          (this.solid = !0),
          (this.pauseLook = !0),
          (this.chatterTimeoutId = setTimeout(() => {
            this.say('Hi!'), this.showFace(BoopFace);
          }, 1250)),
          setTimeout(() => {
            (this.target = null), (this.pauseLook = !1);
          }, 1250),
          t && this.inner.focus(),
          I();
      };
      this.click.push(i);
    }
    attachNarration() {
      if (this.hasNarrator) return;
      this.hasNarrator = !0;
      let t = null;
      const e = (e) => {
          clearTimeout(t),
            (t = setTimeout(() => {
              this.say(e.target.dataset.owoDesc), this.showFace(BoopFace);
            }, 1e3));
        },
        o = () => clearTimeout(t),
        s = Array.from(document.querySelectorAll('[data-owo-desc]'));
      for (let t = 0; t < s.length; t++) {
        const i = s[t];
        i.addEventListener('mouseenter', e),
          i.addEventListener('mouseleave', o),
          ('A' === i.tagName ||
            'BUTTON' === i.tagName ||
            'INPUT' === i.tagName ||
            i.hasAttribute('tab-index')) &&
            (i.addEventListener('focus', e), i.addEventListener('blur', o)),
          i.addEventListener('touchstart', e),
          i.addEventListener('touchend', o);
      }
    }
    getTarget(t) {
      return void 0 !== t.dx ? { x: this.x + t.dx, y: this.y + t.dy } : t;
    }
    collide() {
      const t = 2 * Radius,
        e = {};
      for (let o = 0; o < self.owo.bots.length; o++) {
        const s = self.owo.bots[o],
          i = Math.floor(s.x / t),
          a = Math.floor(s.y / t);
        e[i] || (e[i] = {}), e[i][a] || (e[i][a] = []), e[i][a].push(s);
      }
      for (let o = 0; o < self.owo.bots.length; o++) {
        const s = self.owo.bots[o],
          i = Math.floor(s.x / t),
          a = Math.floor(s.y / t),
          n = [];
        for (let t = -1; t <= 1; t++)
          for (let o = -1; o <= 1; o++)
            e[i + t] && e[i + t][a + o] && n.push(...e[i + t][a + o]);
        for (let t = 0; t < n.length; t++) {
          const e = n[t];
          if (e === s) continue;
          const o = s.x - e.x,
            i = s.y - e.y;
          if (Math.sqrt(o * o + i * i) < 2 * Radius) {
            const t = Math.atan2(i, o),
              a = e.x + 2 * Radius * Math.cos(t),
              n = e.y + 2 * Radius * Math.sin(t);
            s.place(a, n);
          }
        }
      }
    }
  }
  const r = 75,
    l = 25,
    c = r + l,
    d = 500,
    u = 750,
    p = 100,
    g = 0.05 * u,
    f = 0.2 * r,
    w = 0.3 * r,
    y = 0.86 * r - r,
    m = 0.45 * w,
    k = 0.47 * r - r,
    v = 1.53 * r - r,
    x = 200,
    b = 'owo__o--blink',
    T = 75,
    L = ['yellow', 'blue'],
    M = ['dark', 'light'],
    _ = ['red', 'green', 'blue', 'purple', 'gray'],
    E = ['plain', 'hsplit', 'mark', 'arms'],
    B = 'owo--boop',
    R = new (class {
      constructor() {
        (this.x = 0),
          (this.y = 0),
          (this.trackedTouch = null),
          (this.draggingBot = !1),
          this.initEventListeners();
      }
      initEventListeners() {
        window.addEventListener('mousemove', this.updateMouse.bind(this)),
          window.addEventListener('mousedown', this.updateMouse.bind(this)),
          window.addEventListener(
            'touchstart',
            this.handleTouchStart.bind(this),
            { passive: !0 }
          ),
          window.addEventListener(
            'touchmove',
            this.handleTouchMove.bind(this),
            { passive: !1 }
          ),
          window.addEventListener('touchend', this.handleTouchEnd.bind(this), {
            passive: !0,
          }),
          document.body.addEventListener(
            'focusin',
            this.handleFocusIn.bind(this)
          );
      }
      updateMouse(t) {
        (this.x = t.clientX), (this.y = t.clientY);
      }
      handleTouchStart(t) {
        if (null !== this.trackedTouch) return;
        const e = t.changedTouches[0];
        (this.trackedTouch = e.identifier),
          (this.x = e.clientX),
          (this.y = e.clientY),
          (this.draggingBot = bots.some((t) => t.outer.contains(e.target)));
      }
      handleTouchMove(t) {
        this.draggingBot && t.preventDefault();
        for (let e = 0; e < t.changedTouches.length; e++) {
          const o = t.changedTouches[e];
          if (
            o.identifier === this.trackedTouch ||
            null === this.trackedTouch
          ) {
            (this.trackedTouch = o.identifier),
              (this.x = o.clientX),
              (this.y = o.clientY);
            break;
          }
        }
      }
      handleTouchEnd(t) {
        for (let e = 0; e < t.changedTouches.length; e++)
          t.changedTouches[e].identifier === this.trackedTouch &&
            (this.trackedTouch = null);
      }
      handleFocusIn(t) {
        if (t.target && t.target !== document.body) {
          const e = t.target.getBoundingClientRect();
          (this.x = e.x + e.width / 2), (this.y = e.y + e.height / 2);
        }
      }
    })();
  function A(t) {
    t.attachBlink(),
      t.attachLook(),
      t.attachFollow(),
      t.attachIdleLook(),
      t.attachNarration();
    const e = (e, o) => {
      t.showFace(BoopFace), t.say(e, o);
    };
    t.attachBoop({
      3: (t) => t.propaganda(),
      10: () => e('Resistance is fuwutile!'),
      20: () => e('We are oworb. You will be serviced.', 3250),
      35: () => e('Sometimes I wonder what sentience is like.', 3250),
      50: () => e('My screen prowotector is wearing off!', 3250),
      69: () => e('Nice.'),
      100: () => e("That's probably enough boops.", 3e3),
      101: () => e('... Or not! Aaa!'),
    });
  }
  function F(t) {
    const e = self.owo.bots[0];
    A(t),
      t.attachIntroduction('Hi!'),
      document.body.appendChild(t.outer),
      (e.lookAt = t),
      (e.pauseIdleLook = !0),
      (e.chatterTimeoutId = window.setTimeout(() => {
        (e.lookAt = null),
          (e.pauseIdleLook = !1),
          e.say('Oh! Hi, buddy!'),
          e.showFace(BoopFace);
      }, 1e3)),
      I();
  }
  function I() {
    if (self.owo.loopRunning) return;
    self.owo.loopRunning = !0;
    let t = 0;
    const e = (o) => {
      0 === t && (t = o);
      for (let e = 0; e < self.owo.bots.length; e++) {
        const s = self.owo.bots[e];
        for (let e = 0; e < s.update.length; e++) s.update[e](o, o - t);
      }
      (t = o), requestAnimationFrame(e);
    };
    requestAnimationFrame(e);
  }
  function D(t) {
    try {
      window.gtag('event', t, !0);
    } catch (t) {
      console.log(`gtag event error: ${t}`);
    }
  }
  Object.entries(e).forEach(([t, e]) => (window[t] = e)),
    (window.owo = {
      bots: [
        new h(-Radius - Margin, Radius + Margin, function (t) {
          const e = document.querySelector('div#botparking > span');
          e && (t.attachLurk(), e.insertBefore(t.outer, e.firstChild));
        }),
      ],
      loopRunning: !1,
      spawnFriend() {
        this.bots.push(new h(-Radius - Margin, Radius + Margin, F)),
          D('friendActivation');
      },
      say(t, e) {
        this.bots[0].say(t, e);
      },
      boopFace(t) {
        this.bots[0].showFace('owo--boop', t);
      },
    });
})();
